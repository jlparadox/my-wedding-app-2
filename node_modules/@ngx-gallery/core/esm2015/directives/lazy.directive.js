/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
import { Directive, ElementRef, Input, Output, EventEmitter, Renderer2 } from '@angular/core';
import { Subject } from 'rxjs/Subject';
import { switchMap } from 'rxjs/operators/switchMap';
import { tap } from 'rxjs/operators/tap';
import { zip } from 'rxjs/observable/zip';
import { fromEvent } from 'rxjs/observable/fromEvent';
export class LazyDirective {
    /**
     * @param {?} _el
     * @param {?} _renderer
     */
    constructor(_el, _renderer) {
        this._el = _el;
        this._renderer = _renderer;
        this._worker$ = new Subject();
        this.loading = new EventEmitter();
        const /** @type {?} */ img = new Image();
        this._worker$.pipe(switchMap((imageSrc) => {
            // Image is loading
            this.loading.emit(true);
            // Stop previously loading
            img.src = imageSrc;
            // Image load success
            const /** @type {?} */ loadSuccess = fromEvent(img, 'load').pipe(tap(() => {
                this._renderer.setStyle(this._el.nativeElement, 'backgroundImage', `url(${imageSrc})`);
                this.loading.emit(false);
            }));
            // Image load error
            const /** @type {?} */ loadError = fromEvent(img, 'error').pipe(tap(() => this.loading.emit(false)));
            return zip(loadSuccess, loadError);
        })).subscribe();
    }
    /**
     * @param {?} imagePath
     * @return {?}
     */
    set lazyImage(imagePath) {
        this.loadImage(imagePath);
    }
    /**
     * @param {?} imagePath
     * @return {?}
     */
    loadImage(imagePath) {
        this._worker$.next(imagePath);
    }
    /**
     * @return {?}
     */
    ngOnDestroy() {
        this._worker$.complete();
    }
}
LazyDirective.decorators = [
    { type: Directive, args: [{
                selector: '[lazyImage]'
            },] },
];
/** @nocollapse */
LazyDirective.ctorParameters = () => [
    { type: ElementRef, },
    { type: Renderer2, },
];
LazyDirective.propDecorators = {
    "lazyImage": [{ type: Input, args: ['lazyImage',] },],
    "loading": [{ type: Output },],
};
function LazyDirective_tsickle_Closure_declarations() {
    /** @type {!Array<{type: !Function, args: (undefined|!Array<?>)}>} */
    LazyDirective.decorators;
    /**
     * @nocollapse
     * @type {function(): !Array<(null|{type: ?, decorators: (undefined|!Array<{type: !Function, args: (undefined|!Array<?>)}>)})>}
     */
    LazyDirective.ctorParameters;
    /** @type {!Object<string,!Array<{type: !Function, args: (undefined|!Array<?>)}>>} */
    LazyDirective.propDecorators;
    /** @type {?} */
    LazyDirective.prototype._worker$;
    /** @type {?} */
    LazyDirective.prototype.loading;
    /** @type {?} */
    LazyDirective.prototype._el;
    /** @type {?} */
    LazyDirective.prototype._renderer;
}

//# sourceMappingURL=data:application/json;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoibGF6eS5kaXJlY3RpdmUuanMiLCJzb3VyY2VSb290Ijoibmc6Ly9Abmd4LWdhbGxlcnkvY29yZS8iLCJzb3VyY2VzIjpbImRpcmVjdGl2ZXMvbGF6eS5kaXJlY3RpdmUudHMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7OztBQUFBLE9BQU8sRUFDTCxTQUFTLEVBQ1QsVUFBVSxFQUNWLEtBQUssRUFDTCxNQUFNLEVBQ04sWUFBWSxFQUNaLFNBQVMsRUFFVixNQUFNLGVBQWUsQ0FBQztBQUV2QixPQUFPLEVBQUUsT0FBTyxFQUFFLE1BQU0sY0FBYyxDQUFDO0FBRXZDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSwwQkFBMEIsQ0FBQztBQUNyRCxPQUFPLEVBQUUsR0FBRyxFQUFFLE1BQU0sb0JBQW9CLENBQUM7QUFDekMsT0FBTyxFQUFFLEdBQUcsRUFBRSxNQUFNLHFCQUFxQixDQUFDO0FBQzFDLE9BQU8sRUFBRSxTQUFTLEVBQUUsTUFBTSwyQkFBMkIsQ0FBQztBQUt0RCxNQUFNOzs7OztJQVlKLFlBQW9CLEdBQWUsRUFBVSxTQUFvQjtRQUE3QyxRQUFHLEdBQUgsR0FBRyxDQUFZO1FBQVUsY0FBUyxHQUFULFNBQVMsQ0FBVzt3QkFUOUMsSUFBSSxPQUFPLEVBQUU7dUJBT1osSUFBSSxZQUFZLEVBQVc7UUFHN0MsdUJBQU0sR0FBRyxHQUFHLElBQUksS0FBSyxFQUFFLENBQUM7UUFFeEIsSUFBSSxDQUFDLFFBQVEsQ0FBQyxJQUFJLENBQ2hCLFNBQVMsQ0FBQyxDQUFDLFFBQWdCLEVBQUUsRUFBRTs7WUFHN0IsSUFBSSxDQUFDLE9BQU8sQ0FBQyxJQUFJLENBQUMsSUFBSSxDQUFDLENBQUM7O1lBR3hCLEdBQUcsQ0FBQyxHQUFHLEdBQUcsUUFBUSxDQUFDOztZQUduQix1QkFBTSxXQUFXLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxNQUFNLENBQUMsQ0FBQyxJQUFJLENBQzdDLEdBQUcsQ0FBQyxHQUFHLEVBQUU7Z0JBQ1AsSUFBSSxDQUFDLFNBQVMsQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLEdBQUcsQ0FBQyxhQUFhLEVBQUUsaUJBQWlCLEVBQUUsT0FBTyxRQUFRLEdBQUcsQ0FBQyxDQUFDO2dCQUN2RixJQUFJLENBQUMsT0FBTyxDQUFDLElBQUksQ0FBQyxLQUFLLENBQUMsQ0FBQzthQUMxQixDQUFDLENBQ0gsQ0FBQzs7WUFHRix1QkFBTSxTQUFTLEdBQUcsU0FBUyxDQUFDLEdBQUcsRUFBRSxPQUFPLENBQUMsQ0FBQyxJQUFJLENBQUMsR0FBRyxDQUFDLEdBQUcsRUFBRSxDQUFDLElBQUksQ0FBQyxPQUFPLENBQUMsSUFBSSxDQUFDLEtBQUssQ0FBQyxDQUFDLENBQUMsQ0FBQztZQUVwRixNQUFNLENBQUMsR0FBRyxDQUFDLFdBQVcsRUFBRSxTQUFTLENBQUMsQ0FBQztTQUNwQyxDQUFDLENBQ0gsQ0FBQyxTQUFTLEVBQUUsQ0FBQztLQUNmOzs7OztRQWhDRyxTQUFTLENBQUMsU0FBUztRQUNyQixJQUFJLENBQUMsU0FBUyxDQUFDLFNBQVMsQ0FBQyxDQUFDOzs7Ozs7SUFpQzVCLFNBQVMsQ0FBQyxTQUFTO1FBQ2pCLElBQUksQ0FBQyxRQUFRLENBQUMsSUFBSSxDQUFDLFNBQVMsQ0FBQyxDQUFDO0tBQy9COzs7O0lBRUQsV0FBVztRQUNULElBQUksQ0FBQyxRQUFRLENBQUMsUUFBUSxFQUFFLENBQUM7S0FDMUI7OztZQWpERixTQUFTLFNBQUM7Z0JBQ1QsUUFBUSxFQUFFLGFBQWE7YUFDeEI7Ozs7WUFqQkMsVUFBVTtZQUlWLFNBQVM7OzswQkFtQlIsS0FBSyxTQUFDLFdBQVc7d0JBS2pCLE1BQU0iLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQge1xyXG4gIERpcmVjdGl2ZSxcclxuICBFbGVtZW50UmVmLFxyXG4gIElucHV0LFxyXG4gIE91dHB1dCxcclxuICBFdmVudEVtaXR0ZXIsXHJcbiAgUmVuZGVyZXIyLFxyXG4gIE9uRGVzdHJveVxyXG59IGZyb20gJ0Bhbmd1bGFyL2NvcmUnO1xyXG5cclxuaW1wb3J0IHsgU3ViamVjdCB9IGZyb20gJ3J4anMvU3ViamVjdCc7XHJcblxyXG5pbXBvcnQgeyBzd2l0Y2hNYXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycy9zd2l0Y2hNYXAnO1xyXG5pbXBvcnQgeyB0YXAgfSBmcm9tICdyeGpzL29wZXJhdG9ycy90YXAnO1xyXG5pbXBvcnQgeyB6aXAgfSBmcm9tICdyeGpzL29ic2VydmFibGUvemlwJztcclxuaW1wb3J0IHsgZnJvbUV2ZW50IH0gZnJvbSAncnhqcy9vYnNlcnZhYmxlL2Zyb21FdmVudCc7XHJcblxyXG5ARGlyZWN0aXZlKHtcclxuICBzZWxlY3RvcjogJ1tsYXp5SW1hZ2VdJ1xyXG59KVxyXG5leHBvcnQgY2xhc3MgTGF6eURpcmVjdGl2ZSBpbXBsZW1lbnRzIE9uRGVzdHJveSB7XHJcblxyXG4gIC8vIExhenkgbG9hZCB3b3JrZXJcclxuICBwcml2YXRlIF93b3JrZXIkID0gbmV3IFN1YmplY3QoKTtcclxuXHJcbiAgQElucHV0KCdsYXp5SW1hZ2UnKVxyXG4gIHNldCBsYXp5SW1hZ2UoaW1hZ2VQYXRoKSB7XHJcbiAgICB0aGlzLmxvYWRJbWFnZShpbWFnZVBhdGgpO1xyXG4gIH1cclxuXHJcbiAgQE91dHB1dCgpIGxvYWRpbmcgPSBuZXcgRXZlbnRFbWl0dGVyPGJvb2xlYW4+KCk7XHJcblxyXG4gIGNvbnN0cnVjdG9yKHByaXZhdGUgX2VsOiBFbGVtZW50UmVmLCBwcml2YXRlIF9yZW5kZXJlcjogUmVuZGVyZXIyKSB7XHJcbiAgICBjb25zdCBpbWcgPSBuZXcgSW1hZ2UoKTtcclxuXHJcbiAgICB0aGlzLl93b3JrZXIkLnBpcGUoXHJcbiAgICAgIHN3aXRjaE1hcCgoaW1hZ2VTcmM6IHN0cmluZykgPT4ge1xyXG5cclxuICAgICAgICAvLyBJbWFnZSBpcyBsb2FkaW5nXHJcbiAgICAgICAgdGhpcy5sb2FkaW5nLmVtaXQodHJ1ZSk7XHJcblxyXG4gICAgICAgIC8vIFN0b3AgcHJldmlvdXNseSBsb2FkaW5nXHJcbiAgICAgICAgaW1nLnNyYyA9IGltYWdlU3JjO1xyXG5cclxuICAgICAgICAvLyBJbWFnZSBsb2FkIHN1Y2Nlc3NcclxuICAgICAgICBjb25zdCBsb2FkU3VjY2VzcyA9IGZyb21FdmVudChpbWcsICdsb2FkJykucGlwZShcclxuICAgICAgICAgIHRhcCgoKSA9PiB7XHJcbiAgICAgICAgICAgIHRoaXMuX3JlbmRlcmVyLnNldFN0eWxlKHRoaXMuX2VsLm5hdGl2ZUVsZW1lbnQsICdiYWNrZ3JvdW5kSW1hZ2UnLCBgdXJsKCR7aW1hZ2VTcmN9KWApO1xyXG4gICAgICAgICAgICB0aGlzLmxvYWRpbmcuZW1pdChmYWxzZSk7XHJcbiAgICAgICAgICB9KVxyXG4gICAgICAgICk7XHJcblxyXG4gICAgICAgIC8vIEltYWdlIGxvYWQgZXJyb3JcclxuICAgICAgICBjb25zdCBsb2FkRXJyb3IgPSBmcm9tRXZlbnQoaW1nLCAnZXJyb3InKS5waXBlKHRhcCgoKSA9PiB0aGlzLmxvYWRpbmcuZW1pdChmYWxzZSkpKTtcclxuXHJcbiAgICAgICAgcmV0dXJuIHppcChsb2FkU3VjY2VzcywgbG9hZEVycm9yKTtcclxuICAgICAgfSlcclxuICAgICkuc3Vic2NyaWJlKCk7XHJcbiAgfVxyXG5cclxuICBsb2FkSW1hZ2UoaW1hZ2VQYXRoKSB7XHJcbiAgICB0aGlzLl93b3JrZXIkLm5leHQoaW1hZ2VQYXRoKTtcclxuICB9XHJcblxyXG4gIG5nT25EZXN0cm95KCkge1xyXG4gICAgdGhpcy5fd29ya2VyJC5jb21wbGV0ZSgpO1xyXG4gIH1cclxuXHJcbn1cclxuIl19