import { InjectionToken, NgModule } from '@angular/core';

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
/**
 * An implemenation of the masonry library to be used
 * as a dummy when running on a server
 * @param {?} element
 * @param {?} options
 * @return {?}
 */
function MasonryRef(element, options) {
    return {
        layout: () => null,
        destroy: () => null,
        stamp: () => null,
        unstamp: () => null,
        appended: () => null,
        prepended: () => null,
        addItems: () => null,
        remove: () => null,
        on: () => null,
        off: () => null,
        once: () => null,
        reloadItems: () => null,
        getItemElements: () => null
    };
}

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const /** @type {?} */ Masonry = new InjectionToken('Masonry');

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */
const ɵ0 = MasonryRef;
const /** @type {?} */ defaultProviders = [{ provide: Masonry, useValue: ɵ0 }];
/**
 * A simple lightweight module to use Masonry layout in Angular
 *
 * {\@link https://masonry.desandro.com/}
 *
 */
class MasonryModule {
    /**
     * Specify a static method for root module to ensure providers
     * are only provided once but allows the module to still be imported
     * into other modules without reproviding services.
     *
     * \@memberof MasonryModule
     * @param {?=} providers
     * @return {?}
     */
    static forRoot(providers = defaultProviders) {
        return {
            ngModule: MasonryModule,
            providers: providers
        };
    }
}
MasonryModule.decorators = [
    { type: NgModule },
];

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

/**
 * @fileoverview added by tsickle
 * @suppress {checkTypes} checked by tsc
 */

export { MasonryRef, Masonry, MasonryModule };

//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoidGhpc2lzc29vbi1hbmd1bGFyLW1hc29ucnkuanMubWFwIiwic291cmNlcyI6WyJuZzovL0B0aGlzaXNzb29uL2FuZ3VsYXItbWFzb25yeS9hcHAvbWFzb25yeS9tYXNvbnJ5LXJlZi50cyIsIm5nOi8vQHRoaXNpc3Nvb24vYW5ndWxhci1tYXNvbnJ5L2FwcC9tYXNvbnJ5L21hc29ucnktdG9rZW4udHMiLCJuZzovL0B0aGlzaXNzb29uL2FuZ3VsYXItbWFzb25yeS9hcHAvbWFzb25yeS9tYXNvbnJ5Lm1vZHVsZS50cyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNYXNvbnJ5T3B0aW9ucyB9IGZyb20gJy4vbWFzb25yeS1vcHRpb25zLm1vZGVsJztcbmltcG9ydCB7IE1hc29ucnlJbnN0YW5jZSB9IGZyb20gJy4vbWFzb25yeS1pbnN0YW5jZS5tb2RlbCc7XG5cbi8qKlxuICogQW4gaW1wbGVtZW5hdGlvbiBvZiB0aGUgbWFzb25yeSBsaWJyYXJ5IHRvIGJlIHVzZWRcbiAqIGFzIGEgZHVtbXkgd2hlbiBydW5uaW5nIG9uIGEgc2VydmVyXG4gKi9cbmV4cG9ydCBmdW5jdGlvbiBNYXNvbnJ5UmVmKFxuICBlbGVtZW50OiBzdHJpbmcgfCBIVE1MRWxlbWVudCxcbiAgb3B0aW9uczogTWFzb25yeU9wdGlvbnNcbik6IE1hc29ucnlJbnN0YW5jZSB7XG4gIHJldHVybiB7XG4gICAgbGF5b3V0OiAoKSA9PiBudWxsLFxuICAgIGRlc3Ryb3k6ICgpID0+IG51bGwsXG4gICAgc3RhbXA6ICgpID0+IG51bGwsXG4gICAgdW5zdGFtcDogKCkgPT4gbnVsbCxcbiAgICBhcHBlbmRlZDogKCkgPT4gbnVsbCxcbiAgICBwcmVwZW5kZWQ6ICgpID0+IG51bGwsXG4gICAgYWRkSXRlbXM6ICgpID0+IG51bGwsXG4gICAgcmVtb3ZlOiAoKSA9PiBudWxsLFxuICAgIG9uOiAoKSA9PiBudWxsLFxuICAgIG9mZjogKCkgPT4gbnVsbCxcbiAgICBvbmNlOiAoKSA9PiBudWxsLFxuICAgIHJlbG9hZEl0ZW1zOiAoKSA9PiBudWxsLFxuICAgIGdldEl0ZW1FbGVtZW50czogKCkgPT4gbnVsbFxuICB9O1xufVxuIiwiaW1wb3J0IHsgSW5qZWN0aW9uVG9rZW4gfSBmcm9tICdAYW5ndWxhci9jb3JlJztcblxuZXhwb3J0IGNvbnN0IE1hc29ucnkgPSBuZXcgSW5qZWN0aW9uVG9rZW48c3RyaW5nPignTWFzb25yeScpO1xuIiwiaW1wb3J0IHsgTmdNb2R1bGUsIE1vZHVsZVdpdGhQcm92aWRlcnMsIFByb3ZpZGVyIH0gZnJvbSAnQGFuZ3VsYXIvY29yZSc7XG5cbmltcG9ydCB7IE1hc29ucnlSZWYgfSBmcm9tICcuL21hc29ucnktcmVmJztcbmltcG9ydCB7IE1hc29ucnkgfSBmcm9tICcuL21hc29ucnktdG9rZW4nO1xuXG5jb25zdCBkZWZhdWx0UHJvdmlkZXJzID0gW3sgcHJvdmlkZTogTWFzb25yeSwgdXNlVmFsdWU6IE1hc29ucnlSZWYgfV07XG5cbi8qKlxuICogQSBzaW1wbGUgbGlnaHR3ZWlnaHQgbW9kdWxlIHRvIHVzZSBNYXNvbnJ5IGxheW91dCBpbiBBbmd1bGFyXG4gKlxuICoge0BsaW5rIGh0dHBzOi8vbWFzb25yeS5kZXNhbmRyby5jb20vfVxuICpcbiAqL1xuQE5nTW9kdWxlKClcbmV4cG9ydCBjbGFzcyBNYXNvbnJ5TW9kdWxlIHtcbiAgLyoqXG4gICAqIFNwZWNpZnkgYSBzdGF0aWMgbWV0aG9kIGZvciByb290IG1vZHVsZSB0byBlbnN1cmUgcHJvdmlkZXJzXG4gICAqIGFyZSBvbmx5IHByb3ZpZGVkIG9uY2UgYnV0IGFsbG93cyB0aGUgbW9kdWxlIHRvIHN0aWxsIGJlIGltcG9ydGVkXG4gICAqIGludG8gb3RoZXIgbW9kdWxlcyB3aXRob3V0IHJlcHJvdmlkaW5nIHNlcnZpY2VzLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgTWFzb25yeU1vZHVsZVxuICAgKi9cbiAgcHVibGljIHN0YXRpYyBmb3JSb290KFxuICAgIHByb3ZpZGVyczogUHJvdmlkZXJbXSA9IGRlZmF1bHRQcm92aWRlcnNcbiAgKTogTW9kdWxlV2l0aFByb3ZpZGVycyB7XG4gICAgcmV0dXJuIHtcbiAgICAgIG5nTW9kdWxlOiBNYXNvbnJ5TW9kdWxlLFxuICAgICAgcHJvdmlkZXJzOiBwcm92aWRlcnNcbiAgICB9O1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7OztBQU9BLG9CQUNFLE9BQTZCLEVBQzdCLE9BQXVCO0lBRXZCLE9BQU87UUFDTCxNQUFNLEVBQUUsTUFBTSxJQUFJO1FBQ2xCLE9BQU8sRUFBRSxNQUFNLElBQUk7UUFDbkIsS0FBSyxFQUFFLE1BQU0sSUFBSTtRQUNqQixPQUFPLEVBQUUsTUFBTSxJQUFJO1FBQ25CLFFBQVEsRUFBRSxNQUFNLElBQUk7UUFDcEIsU0FBUyxFQUFFLE1BQU0sSUFBSTtRQUNyQixRQUFRLEVBQUUsTUFBTSxJQUFJO1FBQ3BCLE1BQU0sRUFBRSxNQUFNLElBQUk7UUFDbEIsRUFBRSxFQUFFLE1BQU0sSUFBSTtRQUNkLEdBQUcsRUFBRSxNQUFNLElBQUk7UUFDZixJQUFJLEVBQUUsTUFBTSxJQUFJO1FBQ2hCLFdBQVcsRUFBRSxNQUFNLElBQUk7UUFDdkIsZUFBZSxFQUFFLE1BQU0sSUFBSTtLQUM1QixDQUFDO0NBQ0g7Ozs7OztBQzFCRCx1QkFFYSxPQUFPLEdBQUcsSUFBSSxjQUFjLENBQVMsU0FBUyxDQUFDOzs7Ozs7QUNGNUQsV0FLd0QsVUFBVTtBQUFsRSx1QkFBTSxnQkFBZ0IsR0FBRyxDQUFDLEVBQUUsT0FBTyxFQUFFLE9BQU8sRUFBRSxRQUFRLElBQVksRUFBRSxDQUFDLENBQUM7Ozs7Ozs7QUFTdEU7Ozs7Ozs7Ozs7SUFRUyxPQUFPLE9BQU8sQ0FDbkIsWUFBd0IsZ0JBQWdCO1FBRXhDLE9BQU87WUFDTCxRQUFRLEVBQUUsYUFBYTtZQUN2QixTQUFTLEVBQUUsU0FBUztTQUNyQixDQUFDOzs7O1lBZkwsUUFBUTs7Ozs7Ozs7Ozs7Ozs7OyJ9